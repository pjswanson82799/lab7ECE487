//Palmer Swanson
//CWID 11726494
//ECE 487 Lab 7 Memory Simulator

#include <iostream>
#include <math.h>
#include <string>
#include <vector>
#include <fstream>    //for reading files
#include <utility>

struct user_struct {
    int bytesOfMainMemory = 0;
    int bytesOfCacheMemory = 0;
    int blocksize = 0;
    int degreesetAssociativity = 0;
    char replacementpolicy = 'k';
    std::string fileName = "";
};

struct cacheBlock {
    int numberofCacheBlocks = 0;
    int totalbits = 0;
    int tagbits = 0;
    int indexbits = 0;
    int offsetbits = 0;
    int finalsize = 0;
};

struct hitormisstable {
    std::vector<char> readwrite;
    std::vector<int> mainMemAddress;
    std::vector<int> mainMemBlock;
    std::vector<int> cacheMemSet;
    std::vector<std::pair<int, int>> cmpair;
};

struct optimal {
    int hits = 0;
    int total = 0;
    float percentage = 0.0;
};

struct CacheBlocks {
    bool dirtybit = 0;
    bool validbit = 0;
    std::string tag = "";
    std::string data = "";
};

//queries the user to enter an int.  This int will be the size of the main memory in bytes
int main_memory_size_query() {
    int size1;                                                                  //init integer
    std::cout << "Enter the size of main memory in bytes: ";                    //std::cout to get user input
    std::cin >> size1;                                                          //read in inputted value
    return size1;                                                               //return integer
}

//queries the user to enter an int.  This int will be the size of the cache for this iteration of the Simulator
int cache_memory_query() {
    int size2;                                                                  //init integer
    std::cout << "Enter the size of the cache in bytes: ";                     //std::cout to get user input
    std::cin >> size2;                                                         //read in inputted value
    return size2;                                                              //return integer
}

//queries the user to enter an int.  This int will be the size of the cache block for this iteration of the Simulator
int block_size_query() {
    int size3;                                                                //init integer
    std::cout << "Enter the cache block/line size: ";                         //std::cout to get user input
    std::cin >> size3;                                                        //read in inputted value
    return size3;                                                             //return integer
}

//queries the user to enter an int.  This int will be the n-wway set associative mapping for this iteration of the Simulator
int set_associativity_query() {
    int degree;                                                               //init integer
    std::cout << "\nEnter the degree of set-associativity (input n for an n-way set-associative mapping): ";            //std::cout to get user input
    std::cin >> degree;                                                      //read in inputted value
    return degree;                                                          //return integer
}

//queries the user to enter an char.  This char will be thereplacement policy for this iteration of the Simulator
char replacementPolicy_query() {
    char LorF;                                                                        //init char
    std::cout << "Enter the replacement policy (L = LRU, F = FIFO): ";                //std::cout to get user input
    std::cin >> LorF;                                                                //read in inputted value
    return LorF;                                                                    //return integer
}

//queries the user to enter an string.  This string will be the name of the input file for this iteration of the Simulator
std::string inputFileNameQuery() {
    std::string input;                                                                                                                      //init string
    std::cout << "Enter the name of the input file containing the list of memory references generated by the CPU:";                         //query user for input in "filename.txt" format
    std::cin >> input;                                                                                                                     //read in string name
    return input;                                                                                                                          //return string
}

//returns an int that is the number of address lines needed for this simulation.  uses the log2 function from the math.h library
int addresslines_calc(int MainMem) {
    int temp = (int)log2(MainMem);
    return temp;
}

//Calculated the number of bits required for offset.  Input is an int and output is also an int
int bitsforoffset_calc(int blockSize) {
    return (int)log2(blockSize);
}

//Calculates number of bits for index.  Input is the int size of the cache, int block size, and int nway associativity
int bitsforindex_calc(int cacheSize, int blockSize, int nwayassociativity) {
    int blocksInCache = (cacheSize / blockSize);
    int temp = (blocksInCache / nwayassociativity);
    int numOfBits = (int)log2(temp);
    return numOfBits;
}

//Calculates the number of bits for the tag
int bitsforTag_calc(int addressbits, int offsetBits, int indexBits) {
    return (addressbits - offsetBits - indexBits);
}

//returns the number of blocks in Cache Memory from user inputs of Cache size and block size
int numberofCMblks(int sizeofCache, int sizeofBlock) {
    int temp = sizeofCache / sizeofBlock;                                         //create temp variable
    return temp;                                                                //return this temp variable
}

void meat_of_input_file(std::string input_file, std::vector<char>& read_write, std::vector<int>& memorylocations, std::vector<int>& mmblock, std::vector<int>& cmset, int cachesize, int blocksize, int nwayassociativity) {
    int temp = (cachesize/ blocksize);
    int temp1 = (temp/nwayassociativity);
    int number = 0;
    std::string line1;
    std::string word;
    std::string value;
    std::ifstream stream(input_file.c_str());
    stream.ignore(1, '\n');                           //to ignore the first line
    while (getline(stream, line1)) {
        stream >> word >> value;
        read_write.push_back(word[0]);
        number = stoi(value);
        memorylocations.push_back(number);
        mmblock.push_back(number / blocksize);
        cmset.push_back((number/blocksize) % temp1);
    }
    read_write.pop_back();
    memorylocations.pop_back();
    mmblock.pop_back();
    cmset.pop_back();
}

void range_cmblk(std::vector<int> cmset, std::vector<std::pair<int, int>>& p, int associativity){
  int temp;
  int temp1;
  for(int i = 0; i < cmset.size(); i++){
    temp = cmset[i]*associativity;
    temp1 = (cmset[i]*associativity) + (associativity - 1);
    p.push_back(std::make_pair(temp, temp1));
  }
}
//calculates final size of Cache.  INput is the original size of cache, number of CM blocks, and number of tag bits.
int finalsizeofCache(int origianlCMsize, int numOfBlocks, int numberOfTagBits) {
    int temp = (1 + 1 + numberOfTagBits);                       //int for value of the sum of compiler directives and tag bits
    int temp1 = temp * (numOfBlocks);                                           //int for temp*numOfBlocks
    int temp3 = temp1 / 8;                                                      //divide temp1 by 8 bits per byte
    int temp4 = origianlCMsize + temp3;                                       //add this to the original cache memory size
    return temp4;                                                             //return this value
}

//function to convert a decimal tag to binary.  Input is the decimal number n and the number of tag bits
std::string toBinary(int n, int numofTagbits) {
    std::string r;
    for (int i = 0; i < numofTagbits; i++) {            //calculate the binary number consisting of numofTagBits number of bits
        r += (n % 2 == 0 ? "0" : "1");
        n /= 2;
    }
    return r;                                         //return the string of the bianry number
}

void optimal_hit_rate(std::vector<int> mainmemblock, int& hits, int& total, float& percentage) {
    int i, j, count = 0;
    for (i = 0; i < mainmemblock.size(); i++) {
        for (j = i + 1; j < mainmemblock.size(); j++) {
            if (mainmemblock[i] == mainmemblock[j]) {
                count++;
                break;
            }
        }
    }
    hits = count;
    total = mainmemblock.size();
    percentage = (((float)count / mainmemblock.size()) * 100);
}

// formats simulation output required in lab sheet.
void simulator_output(int requiredAddressLines, int offsetbits, int indexbits, int tagbits, int sizeCM) {
    std::cout << "\nSimulator Output:" << std::endl;
    std::cout << "Total address lines required = " << requiredAddressLines << std::endl;
    std::cout << "Number of bits for offset = " << offsetbits << std::endl;
    std::cout << "Number of bits for index = " << indexbits << std::endl;
    std::cout << "Number of bits for tag = " << tagbits << std::endl;
    std::cout << "Total cache size required = " << sizeCM << " bytes" << std::endl;
}

int main(){
    user_struct input;
    cacheBlock usercache;
    hitormisstable readingFile;
    optimal theoreticalhitrate;

    char user_loop_exit;
    bool exit_loop = false;

    while (exit_loop == false) {
        //user input variables.  Input into the struct declcared just inside main
        input.bytesOfMainMemory = main_memory_size_query();
        input.bytesOfCacheMemory = cache_memory_query();
        input.blocksize = block_size_query();
        input.degreesetAssociativity = set_associativity_query();
        input.replacementpolicy = replacementPolicy_query();
        input.fileName = inputFileNameQuery();

        usercache.numberofCacheBlocks = numberofCMblks(input.bytesOfCacheMemory, input.blocksize);

        CacheBlocks CacheMemory[usercache.numberofCacheBlocks];

        usercache.totalbits = addresslines_calc(input.bytesOfMainMemory);
        usercache.offsetbits = bitsforoffset_calc(input.blocksize);
        usercache.indexbits = bitsforindex_calc(input.bytesOfCacheMemory, input.blocksize, input.degreesetAssociativity);
        usercache.tagbits = bitsforTag_calc(usercache.totalbits, usercache.offsetbits, usercache.indexbits);
        usercache.finalsize = finalsizeofCache(input.bytesOfCacheMemory, usercache.numberofCacheBlocks, usercache.tagbits);

        meat_of_input_file(input.fileName, readingFile.readwrite, readingFile.mainMemAddress, readingFile.mainMemBlock, readingFile.cacheMemSet, input.bytesOfCacheMemory, input.blocksize, input.degreesetAssociativity);
        simulator_output(usercache.totalbits, usercache.offsetbits, usercache.indexbits, usercache.tagbits, usercache.finalsize);
        optimal_hit_rate(readingFile.mainMemBlock, theoreticalhitrate.hits, theoreticalhitrate.total, theoreticalhitrate.percentage);

        //std::cout << theoreticalhitrate.hits << std::endl;

        range_cmblk(readingFile.cacheMemSet, readingFile.cmpair, input.degreesetAssociativity);

        //for(int i = 0; i < readingFile.cmpair.size(); i++){
          //std::cout << readingFile.cmpair[i].first << ", " << readingFile.cmpair[i].second << std::endl;
        //}

        std::cout << "\nContinue? (y = yes, n = no): ";
        std::cin >> user_loop_exit;
        if (user_loop_exit == 'n') {
            exit_loop = true;
            break;
        }
    }
}
