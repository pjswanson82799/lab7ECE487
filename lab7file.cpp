#include <iostream>			//basic IO
#include <math.h>       /* log2 */
#include <string>       //for strings
#include <fstream>    //for reading files

#define DIRTYBIT  1
#define VALIDBIT  1

//This function passes by reference the input parameters of this program.  Function queries user for size of main memory, size of cache, block size, n-degree of associativity
//replacement policy, and the name of the file.  Keep in mind that the name of file that the user inputs will always include the .txt ending
//There is nothing too crazy in this function, pretty standard I/O stuff.  I decided to use a string for the name of the input file
void user_input( int &mainMem, int &cache, int &BlockSize, int &associativity, char &L_orF, std::string &inputFile) {
	std::cout << "Enter the size of main memory in bytes: ";
	std::cin >> mainMem;
	std::cout << "Enter the size of the cache in bytes: ";
	std::cin >> cache;
	std::cout << "Enter the cache block/line size: ";
	std::cin >> BlockSize;
	std::cout << "\nEnter the degree of set-associativity (input n for an n-way set-associative mapping): ";
	std::cin >> associativity;
	std::cout << "Enter the replacement policy (L = LRU, F = FIFO): ";
	std::cin >> L_orF;
	std::cout << "Enter the name of the input file containing the list of memory references generated by the CPU:";
	std::cin >> inputFile;
}

//This function takes the values that had data read into them in the user_input function and performs various calculations with them.  Reading in the size of the various memory
//main memory, cache, block, and degree of associiativty, the number of addresslines, number of offset bits, number of index bits, number of tag bits, and number of total bits total bits needed
//are calculated.
void values_required(int sizeofMainMem, int sizeofCache, int BlockSize, int degreeAssociative, int &addressLinesNeeded, int &bitsforOffset, int &bitsforINDEX, int &bitsForTag, int &totalBits){
  int blocksPerSet = 0;
  int numSets = 0;
  addressLinesNeeded = (int) log2(sizeofMainMem);           //basic formula given in class
  bitsforOffset = (int) log2(BlockSize);
  blocksPerSet = (BlockSize * degreeAssociative);
  //std::cout << blocksPerSet << std::endl;
  numSets = (sizeofCache/blocksPerSet);
  //std::cout << numSets << std::endl;
  bitsforINDEX = (int) log2(numSets);
  bitsForTag = (addressLinesNeeded - bitsforOffset - bitsforINDEX);
  totalBits = (sizeofCache + bitsForTag + DIRTYBIT + VALIDBIT);
  //Display to terminal
  std::cout << "\nSimulator output:\n";
  std::cout << "Total address lines required = " << addressLinesNeeded << std::endl;
	std::cout << "Number of bits for offset = " << bitsforOffset << std::endl;
	std::cout << "Number of bits for index = " << bitsforINDEX << std::endl;
	std::cout << "Number of bits for tag = " << bitsForTag << std::endl;
  std::cout << "Total cache size required = " << totalBits << std::endl;
}

//The basic format of the input file is known and given to us: a single number (called M) on the first line followed by a carriage return and a two column, M row  array of data beneath it
//This function reads that first number from the file and nothing else.  I need this first value because i initialize arrays to the size of this number later in the main program
int mem_references_from_file(std::string input_file){
  int number_of_references;
	std::string line;                                                //Creating a string that will pull the first line.  Later will convert to integer
	std::ifstream myfile(input_file.c_str());                        //Now max, you may be wondering why do I need this .c_str() suffix.  Good question.  In C++, you can use strings instead of character arrays
	if (myfile.good()) {                                             //in C++ you go std::string blahblah instead of char blahblah[25] for example.  Some C++ functions have their roots in C and so to convert from a C++ string to a C character array, you use the suffix
    std::getline(myfile, line);                                   //grabs the first line
    number_of_references = std::stoi (line);                      //converts string to an integer
		myfile.close();                                               //Don't exactly need this as fstream will close file automatically but its habit at this point
	}
	else {
		std::cerr << "Can't open file" << std::endl;
	}
  return number_of_references;
}

void meat_of_input_file(std::string input_file, char word_array[], int value_array[]){
  std::string line1;
  std::string word;
  std::string value;
	int i;
  std::ifstream stream(input_file.c_str());
  stream.ignore(1, '\n');                           //to ignore the first line
  while(getline(stream, line1)){
    stream >> word >> value;
		word_array[i] = word[0];
		value_array[i] = stoi (value);
		i++;
  }
}

void mmBlockANDcmSetNum(int mainMemAddress[], int mmblk[], int cmSetArray[], int block_size, int sizeOfArray){
	for (int i =0; i < sizeOfArray; i++){
		mmblk[i] = (mainMemAddress[i]/block_size);
    cmSetArray[i] = (mmblk[i] % block_size);
	}
}

int main() {
	//variables used for exit status prompt
  char user_loop_exit;
  bool exit_loop = false;

  while (exit_loop == false){
    //defining user input variables
    int mainMemoryByteSize = 0;
    int cacheSizeBytes = 0;
    int blocksize = 0;
    int associativityDegree = 0;
    char replacementPolicy = 'k';
    std::string inputFileName = "";

    int tot_address_lines_needed = 0;
    int bitsneededForOffset = 0;
    int bits_for_index = 0;
    int bitsForTag = 0;
    int totalBitsNeeded = 0;

    int numMemRef_fromInput = 0;
    int size = 0;

		//get user input from keyboard and save into declared variables
    user_input(mainMemoryByteSize, cacheSizeBytes, blocksize, associativityDegree, replacementPolicy, inputFileName);
    values_required(mainMemoryByteSize, cacheSizeBytes, blocksize, associativityDegree, tot_address_lines_needed, bitsneededForOffset, bits_for_index, bitsForTag, totalBitsNeeded);

    numMemRef_fromInput = mem_references_from_file(inputFileName);

    char read_write[numMemRef_fromInput];
    int memory_locations[numMemRef_fromInput];
    int mainMemBlockNUM[numMemRef_fromInput];
    int CacheMemSetNUM[numMemRef_fromInput];

    meat_of_input_file(inputFileName.c_str(), read_write, memory_locations);

    size = (sizeof(memory_locations)/sizeof(memory_locations[0]));										//need this bc functions outside of main can't use sizeof() function in C++

    mmBlockANDcmSetNum(memory_locations, mainMemBlockNUM, CacheMemSetNUM, blocksize, size);

    for (int i =0; i < sizeof(mainMemBlockNUM)/sizeof(mainMemBlockNUM[0]); i++){
			std::cout <<  memory_locations[i]<< '\t' << mainMemBlockNUM[i] << '\t' << CacheMemSetNUM[i] << std::endl;
		}

    std::cout << "\nContinue? (y = yes, n = no): ";
    std::cin >> user_loop_exit;
    if (user_loop_exit == 'n') {
      exit_loop = true;
      break;
    }
  }

  return 0;
}
