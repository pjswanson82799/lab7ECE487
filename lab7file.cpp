#include <iostream>			//basic IO
#include <math.h>       /* log2 */
#include <string>       //for strings
#include <fstream>    //for reading files

#define DIRTYBIT  1
#define VALIDBIT  1

//This function passes by reference the input parameters of this program.  Function queries user for size of main memory, size of cache, block size, n-degree of associativity
//replacement policy, and the name of the file.  Keep in mind that the name of file that the user inputs will always include the .txt ending
//There is nothing too crazy in this function, pretty standard I/O stuff.  I decided to use a string for the name of the input file
void user_input( int &mainMem, int &cache, int &BlockSize, int &associativity, char &L_orF, std::string &inputFile) {
	std::cout << "Enter the size of main memory in bytes: ";
	std::cin >> mainMem;
	std::cout << "Enter the size of the cache in bytes: ";
	std::cin >> cache;
	std::cout << "Enter the cache block/line size: ";
	std::cin >> BlockSize;
	std::cout << "\nEnter the degree of set-associativity (input n for an n-way set-associative mapping): ";
	std::cin >> associativity;
	std::cout << "Enter the replacement policy (L = LRU, F = FIFO): ";
	std::cin >> L_orF;
	std::cout << "Enter the name of the input file containing the list of memory references generated by the CPU:";
	std::cin >> inputFile;
}

//This function takes the values that had data read into them in the user_input function and performs various calculations with them.  Reading in the size of the various memory
//main memory, cache, block, and degree of associiativty, the number of addresslines, number of offset bits, number of index bits, number of tag bits, and number of total bits total bits needed
//are calculated.
void values_required(int sizeofMainMem, int sizeofCache, int BlockSize, int degreeAssociative, int &addressLinesNeeded, int &bitsforOffset, int &bitsforINDEX, int &bitsForTag, int &totalBits){
  int blocksPerSet = 0;
  int numSets = 0;
  addressLinesNeeded = (int) log2(sizeofMainMem);           //basic formula given in class
  bitsforOffset = (int) log2(BlockSize);
  blocksPerSet = (BlockSize * degreeAssociative);
  //std::cout << blocksPerSet << std::endl;
  numSets = (sizeofCache/blocksPerSet);
  //std::cout << numSets << std::endl;
  bitsforINDEX = (int) log2(numSets);
  bitsForTag = (addressLinesNeeded - bitsforOffset - bitsforINDEX);
  totalBits = (sizeofCache + bitsForTag + DIRTYBIT + VALIDBIT);
  //Display to terminal
  std::cout << "\nSimulator output:\n";
  std::cout << "Total address lines required = " << addressLinesNeeded << std::endl;
	std::cout << "Number of bits for offset = " << bitsforOffset << std::endl;
	std::cout << "Number of bits for index = " << bitsforINDEX << std::endl;
	std::cout << "Number of bits for tag = " << bitsForTag << std::endl;
  std::cout << "Total cache size required = " << totalBits << std::endl;
}

//The basic format of the input file is known and given to us: a single number (called M) on the first line followed by a carriage return and a two column, M row  array of data beneath it
//This function reads that first number from the file and nothing else.  I need this first value because i initialize arrays to the size of this number later in the main program
int mem_references_from_file(std::string input_file){
  int number_of_references;                                        //initialize an int to hold the converted int from string
	std::string line;                                                //Creating a string that will pull the first line.  Later will convert to integer
	std::ifstream myfile(input_file.c_str());                        //Now max, you may be wondering why do I need this .c_str() suffix.  Good question.  In C++, you can use strings instead of character arrays
	if (myfile.good()) {                                             //in C++ you go std::string blahblah instead of char blahblah[25] for example.  Some C++ functions have their roots in C and so to convert from a C++ string to a C character array, you use the suffix
    std::getline(myfile, line);                                   //grabs the first line
    number_of_references = std::stoi (line);                      //converts string to an integer
		myfile.close();                                               //Don't exactly need this as fstream will close file automatically but its habit at this point
	}
	else {
		std::cerr << "Can't open file" << std::endl;                  //error function might remove later as we can assume that all input will be valid, alledgedly
	}
  return number_of_references;                                    //return the number from the first line of the file
}

//This function gathers the data from the file and puts it into two arrays, one a char array that holds whether the memoryu location is a read or a write and another to hold the int value of the memory location
void meat_of_input_file(std::string input_file, char word_array[], int value_array[]){
  std::string line1;
  std::string word;                                               //at this point, I realize that this is probably not the best way to parse an input stream.  But it worked.  Created two strings, one for the R/W colum and another for the memory location
  std::string value;
	int i;                                                         //iterator to populate the arrays
  std::ifstream stream(input_file.c_str());                       //open up file for reading again
  stream.ignore(1, '\n');                                         //to ignore the first line because we pulled that number from the previous function
  while(getline(stream, line1)){                                  //loop until the end of the file
    stream >> word >> value;                                      //read into the stream the two values, seperated by a space
		word_array[i] = word[0];                                      //because the first value in each row is a letter, to get a char from the string i set ith value to the first element of the string.
		value_array[i] = stoi (value);                                //string to integer for the memory location.
		i++;
  }
}

//This functyion populates the mmblk array and set array, performing calculations on elements of the arrays.  The first parameter is the array of main memory addresses, gleaned from the input file
//The second and third parameters are empty arrays already initialized using the number of memory locations from the first line in the input file
//the fourth input parameter is from user input, the size of the block
//The fourth paramter is the size of the array, gathered from the mainfunction.  More detail as to why I had to input another parameter instead of defining the size of the array inside the functions
//can be found inside of main, but basically, functions outside of main can't use sizeof() function in C++
void mmBlockANDcmSetNum(int mainMemAddress[], int mmblk[], int cmSetArray[], int block_size, int sizeOfArray){
	for (int i =0; i < sizeOfArray; i++){																					//loop through the entire array
		mmblk[i] = (mainMemAddress[i]/block_size);																	//from the main memory array, the mmblk array is populated by dividing each element by the block size
    cmSetArray[i] = (mmblk[i] % block_size);																		//from main meory array, the cmSetArray is populated by doing mod division by the block size
	}
}

void first_table(int main_memory_addresses[], int mmblkNum[], int size) {
	std::cout << "Main Memory Address\t MM Blk#\t Cm Set#\t Cm Blk#\t hit/miss" << std::endl;
	std::cout << "__________________________________________________________________________________" << std::endl;
}

void second_table(int numofCacheblks){
	std::cout << "Cache blk #\t dirty bit\t valid bit\t tag\t Data" << std::endl;
	std::cout << "_______________________________________________________________" << std::endl;
	for (int i = 0; i < numofCacheblks; i++){
		std::cout << i << std::endl;
	}
}

int main() {
	//variables used for exit status prompt
  char user_loop_exit;
  bool exit_loop = false;

  while (exit_loop == false){
    //defining user input variables
    int mainMemoryByteSize = 0;
    int cacheSizeBytes = 0;
    int blocksize = 0;
    int associativityDegree = 0;
    char replacementPolicy = 'k';
    std::string inputFileName = "";

		//variables that will hold data passed to it by reference
    int tot_address_lines_needed = 0;
    int bitsneededForOffset = 0;
    int bits_for_index = 0;
    int bitsForTag = 0;
    int totalBitsNeeded = 0;

    int numMemRef_fromInput = 0;
    int size = 0;

		//get user input from keyboard and save into declared variables
    user_input(mainMemoryByteSize, cacheSizeBytes, blocksize, associativityDegree, replacementPolicy, inputFileName);
    values_required(mainMemoryByteSize, cacheSizeBytes, blocksize, associativityDegree, tot_address_lines_needed, bitsneededForOffset, bits_for_index, bitsForTag, totalBitsNeeded);

    numMemRef_fromInput = mem_references_from_file(inputFileName);

    char read_write[numMemRef_fromInput];
    int memory_locations[numMemRef_fromInput];
    int mainMemBlockNUM[numMemRef_fromInput];
    int CacheMemSetNUM[numMemRef_fromInput];

    meat_of_input_file(inputFileName.c_str(), read_write, memory_locations);

    size = (sizeof(memory_locations)/sizeof(memory_locations[0]));										//need this bc functions outside of main can't use sizeof() function in C++

    mmBlockANDcmSetNum(memory_locations, mainMemBlockNUM, CacheMemSetNUM, blocksize, size);

    for (int i =0; i < sizeof(mainMemBlockNUM)/sizeof(mainMemBlockNUM[0]); i++){
			std::cout <<  memory_locations[i]<< '\t' << mainMemBlockNUM[i] << '\t' << CacheMemSetNUM[i] << std::endl;
		}

    first_table(memory_locations, mainMemBlockNUM, size);
		second_table(cacheBlock);

    std::cout << "\nContinue? (y = yes, n = no): ";
    std::cin >> user_loop_exit;
    if (user_loop_exit == 'n') {
      exit_loop = true;
      break;
    }
  }

  return 0;
}
