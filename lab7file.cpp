//Palmer Swanson
//CWID 11726494
//ECE 487 Lab 7 Memory Simulator

#include <iostream>     //standard I/O
#include <math.h>       /* log2 */
#include <string>       //for strings
#include <fstream>    //for reading files
#include <array>
#include <bitset>

#define VALIDBIT  1
#define DIRTYBIT 1

//queries the user to enter an int.  This int will be the size of the main memory in bytes
int main_memory_size_query(){
  int size1;                                                                  //init integer
  std::cout << "Enter the size of main memory in bytes: ";                    //std::cout to get user input
  std::cin >> size1;                                                          //read in inputted value
  return size1;                                                               //return integer
}

//queries the user to enter an int.  This int will be the size of the cache for this iteration of the Simulator
int cache_memory(){
  int size2;                                                                  //init integer
  std::cout << "Enter the size of the cache in bytes: ";                     //std::cout to get user input
	std::cin >> size2;                                                         //read in inputted value
  return size2;                                                              //return integer
}

//queries the user to enter an int.  This int will be the size of the cache block for this iteration of the Simulator
int block_size(){
  int size3;                                                                //init integer
  std::cout << "Enter the cache block/line size: ";                         //std::cout to get user input
	std::cin >> size3;                                                        //read in inputted value
  return size3;                                                             //return integer
}

//queries the user to enter an int.  This int will be the n-wway set associative mapping for this iteration of the Simulator
int set_associativity(){
  int degree;                                                               //init integer
  std::cout << "\nEnter the degree of set-associativity (input n for an n-way set-associative mapping): ";            //std::cout to get user input
	std::cin >> degree;                                                      //read in inputted value
  return degree;                                                          //return integer
}

//queries the user to enter an char.  This char will be thereplacement policy for this iteration of the Simulator
char replacementPolicy(){
  char LorF;                                                                        //init char
  std::cout << "Enter the replacement policy (L = LRU, F = FIFO): ";                //std::cout to get user input
	std::cin >> LorF;                                                                //read in inputted value
  return LorF;                                                                    //return integer
}

//queries the user to enter an string.  This string will be the name of the input file for this iteration of the Simulator
std::string inputFileNameQuery(){
  std::string input;                                                                                                                      //init string
  std::cout << "Enter the name of the input file containing the list of memory references generated by the CPU:";                         //query user for input in "filename.txt" format
	std::cin >> input;                                                                                                                     //read in string name
  return input;                                                                                                                          //return string
}

//returns the number of blocks in Cache Memory from user inputs of Cache size and block size
int numberofCMblks(int sizeofCache, int sizeofBlock){
  int temp = sizeofCache/sizeofBlock;                                         //create temp variable
  return temp;                                                                //return this temp variable
}

//fills array of cache plots from 0-n, n being the the number of blks minus 1
int fillCacheblkArray(int numberofblocks, int cmblkarray[]){
  for(int i = 0; i < numberofblocks; i++){
    cmblkarray[i] = i;                                                          //populating array
  }
}

//returns an int that is the number of address lines needed for this simulation.  uses the log2 function from the math.h library
int address_lines_required(int m_Value) {
	return (int)log2(m_Value);
}

//Calculated the number of bits required for offset.  Input is an int and output is also an int
int bitsforoffset(int blockSize){
  return (int)log2(blockSize);
}

int bitsforIndex(int cacheSize, int blockSize, int nwayassociativity){
  int blocksInCache = (cacheSize/blockSize);
  int temp = (blocksInCache/nwayassociativity);
  int numOfBits = (int)log2(temp);
  return numOfBits;
}

int bitsforTag(int addressbits, int offsetBits, int indexBits){
  return (addressbits - offsetBits - indexBits);
}

int finalsizeofCache(int sizeOfOriginalCache, int numberOfTagBits){
  return (sizeOfOriginalCache + VALIDBIT + DIRTYBIT  + numberOfTagBits);
}

int mem_references_from_file(std::string input_file){
  int number_of_references;
	std::string line;
	std::ifstream myfile(input_file.c_str());
	if (myfile.good()) {
    std::getline(myfile, line);
    number_of_references = std::stoi (line);
		myfile.close();
	}
	else {
		std::cerr << "Can't open file" << std::endl;
	}
  return number_of_references;
}

void meat_of_input_file(std::string input_file, char word_array[], int value_array[]){
  std::string line1;
  std::string word;
  std::string value;
	int i;
  std::ifstream stream(input_file.c_str());
  stream.ignore(1, '\n');                           //to ignore the first line
  while(getline(stream, line1)){
    stream >> word >> value;
		word_array[i] = word[0];
		value_array[i] = stoi (value);
		i++;
  }
}

void mmBlockANDcmSetNum(int mainMemAddress[], int mmblk[], int cmSetArray[], int cachesize, int blocksize, int sizeOfArray, int nwayassociativity){
  int temp = (cachesize/blocksize);
  int temp1 = (temp/nwayassociativity);
	for (int i =0; i < sizeOfArray; i++){
		mmblk[i] = (mainMemAddress[i]/blocksize);
    cmSetArray[i] = (mmblk[i] % temp1);
	}
}

void range_cmblk(int cm_set[], int associativity, int bottomarray[], int toparray[], int size){
  int temp;
  int temp1;
  for(int i = 0; i < size; i++){
    temp = cm_set[i]*associativity;
    temp1 = (cm_set[i]*associativity) + (associativity - 1);
    bottomarray[i] = temp;
    toparray[i] = temp1;
  }
}

void tobinary(int mainMemAddress[], std::string binarymainMemAddress[], int adresslines, int size){
  std::string binary;
  for(int i = 0; i <size; i++){
    binary = std::bitset<15>(mainMemAddress[i]).to_string();
    binarymainMemAddress[i] = binary;
    std::cout << binarymainMemAddress[i] << std::endl;
    //std::cout << binary[0] << std::endl;
    //std::cout << binary[14] << std::endl;
  }
}

void gettag(std::string binarystring[], std::string tag[], int numoftagbits, int addresslines, int size){
  std::string temp;
  std::string temptag;
  int startingpos = 15-addresslines;
  int endingpos = startingpos + numoftagbits;
  for(int i = 0; i < size; i++){
    temp = binarystring[i];
    temptag = temp.substr(startingpos,endingpos);
    tag[i] = temptag;
    std::cout << temptag << std::endl;
  }
}

void hit_miss(int mmblk[], int cmset[], int cmblk[], int minrange[], int maxrange[], bool validbit[], int size){
  for (int i = 0; i < size; i++){
    if (cmset[i] >= minrange[i] && cmset[i] <= maxrange[i] && validbit[i] == 0){
      validbit[i] = 1;
    }
    else if(cmset[i] >= minrange[i] && cmset[i] <= maxrange[i] && validbit[i] == 1){
      std::cout << "HIT" << std::endl;
    }
  }
}

//formats simulation output required in lab sheet.
void simulator_output(int requiredAddressLines, int offsetbits, int indexbits, int tagbits){
  std::cout << "\nSimulator Output:" << std::endl;
  std::cout << "Total address lines required = " << requiredAddressLines << std::endl;
  std::cout << "Number of bits for offset = " << offsetbits << std::endl;
  std::cout << "Number of bits for index = " << indexbits << std::endl;
  std::cout << "Number of bits for tag = " << tagbits << std::endl;
}

void firsttable(int main_memory_addresses[], int mmblkNum[], int cmsetNum[], int mincmblock[], int maxcmblock[], int size){
  std::cout << "\nMain Memory Address\t MM Blk#\t Cm Set#\t Cm Blk#\t hit/miss" << std::endl;
  std::cout << "----------------------------------------------------------------------------------" << std::endl;
  for (int i =0; i < size; i++){
		std::cout << "\t  " << main_memory_addresses[i] << "\t\t    " << mmblkNum[i] << "\t\t    " << cmsetNum[i];
    std::cout << "\t\t   " << mincmblock[i] << "-" << maxcmblock[i] <<std::endl;
	}
}

float optimal_hit_rate(int main_memory_blocks[], int sizeOfArray){
  int i, j, count = 0;
  float percentage = 0;
  for(i = 0; i < sizeOfArray; i++){
    for (j = i+1; j < sizeOfArray; j++){
      if(main_memory_blocks[i] == main_memory_blocks[j]){
        count++;
        break;
      }
    }
  }
  percentage = (((float) count/sizeOfArray)*100);
  return percentage;
}

void finalstatusofCache(int cacheblkarray[], bool dirty[], bool valid[], int numberofblks){
  std::cout <<"\nFinal “status” of the cache:" << std::endl;
	std::cout << "Cache blk #\t dirty bit\t valid bit\t tag\t Data" << std::endl;
  std::cout << "---------------------------------------------------------------" <<std::endl;
  for (int i =0; i < numberofblks; i++){
    std::cout << "\t" << cacheblkarray[i] << "\t     " << dirty[i] << "\t\t     " << valid[i] << std::endl;
  }
}

int main() {
  //variables used for exit status prompt
  char user_loop_exit;
  bool exit_loop = false;

    while (exit_loop == false){
      int sizeOfMainMemory = main_memory_size_query();
      int sizeOfCacheMemory = cache_memory();
      int sizeOfBlock = block_size();
      int DegreeOfAssociativity = set_associativity();
      char policyOfReplacement = replacementPolicy();
      std::string inputFileName = inputFileNameQuery();
      int numOfAddressLines = address_lines_required(sizeOfMainMemory);
      int numberofCacheBlocks = numberofCMblks(sizeOfCacheMemory, sizeOfBlock);
      int numOfOffsetBits = bitsforoffset(sizeOfBlock);
      int numOfIndexBits = bitsforIndex(sizeOfCacheMemory, sizeOfBlock, DegreeOfAssociativity);
      int numOfTagBits = bitsforTag(numOfAddressLines, numOfOffsetBits, numOfIndexBits);
      int sizeOfCacheRequired = finalsizeofCache(sizeOfCacheMemory, numOfTagBits);

      int numberofmemoryrefs = mem_references_from_file(inputFileName);

      char read_write[numberofmemoryrefs];
      int memory_locations[numberofmemoryrefs];
      std::string memory_in_binary[numberofmemoryrefs];
      int mainMemBlocknum[numberofmemoryrefs];
      int CacheMemSetnum[numberofmemoryrefs];
      int CacheMemBlocknum[numberofCacheBlocks];
      int mincmblknum[numberofmemoryrefs];
      int maxcmblknum[numberofmemoryrefs];
      bool validbit[numberofCacheBlocks] = {0};                            //want every valid bit to be 0 at first
      bool dirtybit[numberofCacheBlocks] = {0};
      std::string tags[numberofmemoryrefs];

      fillCacheblkArray(numberofCacheBlocks, CacheMemBlocknum);

      meat_of_input_file(inputFileName.c_str(), read_write, memory_locations);
      int size = (sizeof(memory_locations)/sizeof(memory_locations[0]));										//need this bc functions outside of main can't use sizeof() function in C++
      mmBlockANDcmSetNum(memory_locations, mainMemBlocknum, CacheMemSetnum, sizeOfCacheMemory, sizeOfBlock, size, DegreeOfAssociativity);
      range_cmblk(CacheMemSetnum, DegreeOfAssociativity, mincmblknum, maxcmblknum, size);

      hit_miss(mainMemBlocknum, CacheMemSetnum, CacheMemBlocknum, mincmblknum, maxcmblknum, validbit, size);
      simulator_output(numOfAddressLines, numOfOffsetBits, numOfIndexBits, numOfTagBits);
      int optimalHitRate = optimal_hit_rate(mainMemBlocknum, size);
      firsttable(memory_locations, mainMemBlocknum, CacheMemSetnum, mincmblknum, maxcmblknum, size);
      finalstatusofCache(CacheMemBlocknum, dirtybit, validbit, numberofCacheBlocks);

      //debug
      /*
      std::cout << sizeOfMainMemory << std::endl;
      std::cout << sizeOfCacheMemory << std::endl;
      std::cout << sizeOfBlock << std::endl;
      std::cout << DegreeOfAssociativity << std::endl;
      std::cout << policyOfReplacement << std::endl;
      std::cout << inputFileName << std::endl;
      std::cout << numberofmemoryrefs << std::endl;

      for (int i =0; i < sizeof(memory_locations)/sizeof(memory_locations[0]); i++){
        std::cout <<  memory_locations[i]<< '\t' << mainMemBlocknum[i] << '\t' << CacheMemSetnum[i] << std::endl;
      }
      std::cout << optimalHitRate << "%" << std::endl;
      */

      //tobinary(memory_locations, memory_in_binary, numOfAddressLines, size);
      //gettag(memory_in_binary, tags, numOfTagBits, numOfAddressLines, size);
      //std::cout << numberofCacheBlocks << std::endl;
      //exit loop condition at the end of the program
      std::cout << "\nContinue? (y = yes, n = no): ";
      std::cin >> user_loop_exit;
      if (user_loop_exit == 'n') {
        exit_loop = true;
        break;
      }
    }
}
